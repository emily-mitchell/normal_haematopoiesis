
####################################################################################################
#
# "Round 1" simulations are the simulations used to perform ABC sampling.
# "Round 2" simulations ("resimulations") are the simulations used to perform PPC calculations.
#
# After completion of ABC computation at the end of "round 1", we have
# a sample of parameter vectors from the (approximate) posterior distribution;
# 
# At the start of "round 2", we take this pre-existing sample of parameter vectors from this (approximate) posterior distribution
# (OR a sub-sample drawn withOUT replacment from this pre-existing sample of parameter vectors),
# and for each parameter vector in this sample, we perform (a large number of) simulations
# from conditional distribution at each parameter vector;
# (by running script: resim_conditionals_drivers.R);
#
# This sample (the output from the script: resim_conditionals_drivers.R)
# is the input for the present script (compute_conditionals_drivers.R);
#
# In fact, the script: resim_conditionals_drivers.R;
# is run many times within an "job array" on the computing cluster (farm5),
# so that may separate output files are generated;
# The present script (compute_conditionals_drivers.R) collects and pools together all these output files;
#
# The present script (compute_conditionals_drivers.R) uses this large sample of simulated data sets (from each conditional distribution)
# to compute moments (mean and standard deviation) of each conditional distribution (conditional on each parameter vector),
# for each summary statistic;
#
# We may also need the output (observed values of the summary statistics) form the script: calc_obs_stats_test_drivers.R;
# (Only needed when the observed values of the summary satatistics have not already been computed for all individuals, by the script: run_ABC_drivers.R;)
#
# The present script (compute_conditionals_drivers.R) also collects and pools all these samples from the conditional distributions
# to obtain a stratified sample from the posterior predictive distribution for each summary statistic;
#
# For each summary statistic, the (stratified) sample from the posterior predictive distribution is transformed to obtain
# a sample from the posterior predictive distribution of the standardised residual of the specified summary statistic;
# In addition to these "simulated" standardised residuals, 
# we can also compute "observed" standardised residuals;
#
# The present script (compute_conditionals_drivers.R) also computes a "default" posterior predictive p-value.
# In general, this "default" p-value is not the p-value which we really want to compute.
# The "default" posterior predictive p-value is computed using all available summary statistics, ad is associated with the stat_set_ID = "all");
#
####################################################################################################

## Run on farm5
args = commandArgs(TRUE)
args

##SET FILEPATHS
source_directory = toString(args[1])
conditional_resim_directory = toString(args[2])
posterior_sample_file = toString(args[3])
obs_stats_file = toString(args[4])
output_directory = toString(args[5])
pooled_resim_file_name = toString(args[6])
n_resims_per_post_obs = as.integer(args[7])
patient_ID = toString(args[8])

stat_set_ID = "all"


library(tidyr)
library(dplyr)
# library(seqinr)

####################################################################################################
#
# Read "resim" files and collect the simulations (from the conditional distributions)
# generated by the script: resim_conditionals_drivers.R;
#

# sim_file_list = list.files( path = sim_directory, pattern = "sim_" )
resim_file_list = list.files( path = conditional_resim_directory, pattern = "resim_stats_post_obs_" )

cat( "0.0. compute_conditionals_drivers.R main: length( resim_file_list ) = ", length( resim_file_list ), "\n", sep = "\t" )
# readLines("stdin",n=1)


setwd( conditional_resim_directory )
resim_table_list = list()
for( i in 1:length( resim_file_list ) )
{
	resim_file = resim_file_list[[ i ]]
	
	if( file_test( "-f", resim_file ) )
	{
		resim_result = try( resim_table <- read.table( file = resim_file, sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE ) )
		if( class( resim_result ) != "try-error" )
		{
			resim_table_list = append( resim_table_list, list( resim_table ) )
			
		}
		
	}
	
}

n_resim_outfiles = length( resim_table_list )

cat( "0.1. compute_conditionals_drivers.R main: length( resim_table_list ) = ", length( resim_table_list ), "\n", sep = "\t" )
# readLines("stdin",n=1)


if( length( resim_table_list ) > 0 ) 
{
	if( length( resim_table_list ) == 1 ) 
	{
		pooled_resim_table = resim_table_list[[ 1 ]]
		
	}else
	{
		pooled_resim_table <- do.call( "rbind", resim_table_list )
		
	}
	
} # if( length( resim_files ) > 0 )

cat( "0.2. compute_conditionals_drivers.R main: dim( pooled_resim_table ) = ", dim( pooled_resim_table ), "\n", sep = "\t" )
cat( "0.2. compute_conditionals_drivers.R main: names( pooled_resim_table ) = ", names( pooled_resim_table ), "\n", sep = "\t" )
# readLines("stdin",n=1)

####################################################################################################
#
# Create vectors of column names;
# Create data frame "stratified_resim_table";
# 

cols_params= c("number_drivers_per_year","gamma_shape","gamma_rate")
# number_stats=32
cols_stats= c("mean_muts_sim", "n_singletons_1","clade_size_a_1","clade_size_b_1","clade_size_c_1","clade_size_d_1","clade_size_e_1","n_singletons_2","clade_size_a_2","clade_size_b_2","clade_size_c_2","clade_size_d_2","clade_size_e_2", "n_singletons_3", "clade_size_a_3","clade_size_b_3","clade_size_c_3","clade_size_d_3","clade_size_e_3","n_singletons_4", "clade_size_a_4","clade_size_b_4","clade_size_c_4","clade_size_d_4","clade_size_e_4", "ltt_1", "ltt_2", "ltt_3", "ltt_4", "coal_1", "coal_2", "coal_3")

cat( "1.0. compute_conditionals_drivers.R main: length( cols_stats ) = ", length( cols_stats ), "\n", sep = "\t" )
# readLines("stdin",n=1)
	  
n_top_drivers = 5
top_drivers_col_names_vect = sapply( 1:n_top_drivers, function(x){ paste( "driver_fitness_", x, sep="" ) } )

n_top_clades = 5
top_clades_col_names_vect = sapply( 1:n_top_clades, function(x){ paste( "clade_fitness_", x, sep="" ) } )

driver_count_col_names_vect = c( "shared_drivers", "private_drivers", "total_drivers" )

hidden_variable_col_names_vect = c( top_drivers_col_names_vect, top_clades_col_names_vect, driver_count_col_names_vect )


conditional_mean_col_names_vect = sapply( cols_stats, function(x){ paste( "mean_", x, sep="" ) } )
conditional_SD_col_names_vect = sapply( cols_stats, function(x){ paste( "SD_", x, sep="" ) } )

sim_residual_col_names_vect = sapply( cols_stats, function(x){ paste( "sim_std_resid_", x, sep="" ) } )
obs_residual_col_names_vect = sapply( cols_stats, function(x){ paste( "obs_std_resid_", x, sep="" ) } )

resim_col_names_vect = c( "post_obs_index", "n_resims", cols_params, hidden_variable_col_names_vect, cols_stats, conditional_mean_col_names_vect, conditional_SD_col_names_vect, sim_residual_col_names_vect, obs_residual_col_names_vect )
#resim_col_names_vect = c( "post_obs_index", "n_resims", hidden_variable_col_names_vect, cols_stats, conditional_mean_col_names_vect, conditional_SD_col_names_vect, sim_residual_col_names_vect, obs_residual_col_names_vect )
stratified_resim_table = as.data.frame( matrix( NA, nrow = nrow( pooled_resim_table ), ncol = length( resim_col_names_vect ) ) )
names( stratified_resim_table ) <- resim_col_names_vect

# 
# Fill data frame "stratified_resim_table" columns:
# "post_obs_index";
# hidden_variable_col_names_vect;
# cols_stats;
#

stratified_resim_table[ , c( "post_obs_index", hidden_variable_col_names_vect, cols_stats ) ] <- pooled_resim_table[ , c( "post_obs_index", hidden_variable_col_names_vect, cols_stats ) ]

post_obs_order_index_vect = order( stratified_resim_table[[ "post_obs_index" ]] )
stratified_resim_table = stratified_resim_table[ post_obs_order_index_vect, ]

####################################################################################################
# 
# Fill data frame "stratified_resim_table" columns:
# "cols_params";
#

if( file_test( "-f", posterior_sample_file ) )
{
	# posterior_table = read.table( file = posterior_sample_file, sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE ) )
	posterior_result = try( posterior_table <- read.table( file = posterior_sample_file, sep = "\t", header = TRUE, row.names = NULL, stringsAsFactors = FALSE ) )
	if( class( posterior_result ) != "try-error" )
	{
		post_obs_index_vect = stratified_resim_table[[ "post_obs_index" ]]
		stratified_resim_table[ , cols_params ] = posterior_table[ post_obs_index_vect, cols_params ]
		
	}
}

####################################################################################################
#
# Read summary statistics computed from observed data from file "obs_stats_file";
#

obs_stats_table = read.table( file = obs_stats_file, sep = "\t", header=TRUE, row.names = NULL, stringsAsFactors = FALSE )

# obs_stats_vect = t( as.vector( obs_stats_table[ 1, cols_stats ] ) )
obs_stats_vect = unlist( obs_stats_table[ 1, cols_stats ] )

####################################################################################################
# 
# Fill data frame "stratified_resim_table" columns:
# conditional_mean_col_names_vect;
# conditional_SD_col_names_vect;
# sim_residual_col_names_vect;
# obs_residual_col_names_vect;
#

# 
# Count number of resims obtained for each "post_obs_index";
#

temp_tible <- stratified_resim_table %>%
	group_by_at( c( "post_obs_index" ) ) %>%
	mutate( n_resims = n() ) %>%
	ungroup()

stratified_resim_table[[ "n_resims" ]] <- temp_tible[[ "n_resims" ]]

# 
# Compute (estimated) means of summary statistics under conditional distributions;
# (conditional on parameter vector specified by "post_obs_index");
#

temp_tible <- stratified_resim_table %>% 
	group_by_at( c( "post_obs_index" ) ) %>% 
	mutate_at( cols_stats, mean ) %>%
	ungroup()

stratified_resim_table[ , conditional_mean_col_names_vect ] <- temp_tible[ , cols_stats ]

# 
# Compute (estimated) standard deviations of summary statistics under conditional distributions;
# (conditional on parameter vector specified by "post_obs_index");
#

temp_tible <- stratified_resim_table %>% 
	group_by_at( c( "post_obs_index" ) ) %>% 
	mutate_at( cols_stats, sd ) %>%
	ungroup()

stratified_resim_table[ , conditional_SD_col_names_vect ] <- temp_tible[ , cols_stats ]

# 
# Compute standardised residuals for "simulated data";
#

sim_stats_mat = as.matrix( stratified_resim_table[ , cols_stats ] )

sim_mean_mat = as.matrix( stratified_resim_table[ , conditional_mean_col_names_vect ] )

sim_SD_mat = as.matrix( stratified_resim_table[ , conditional_SD_col_names_vect ] )

sim_residual_mat = sim_stats_mat - sim_mean_mat

sim_residual_mat = sim_residual_mat / sim_SD_mat

stratified_resim_table[ , sim_residual_col_names_vect ] <- sim_residual_mat

# 
# Compute standardised residuals for "observed data";
#

# obs_residual_mat = obs_stats_vect - sim_mean_mat
obs_residual_mat = t( - t( sim_mean_mat ) + obs_stats_vect )

obs_residual_mat = obs_residual_mat / sim_SD_mat

stratified_resim_table[ , obs_residual_col_names_vect ] <- obs_residual_mat

####################################################################################################
# 
# Write data frame "stratified_resim_table" to outfile;
#

cat( "4.0. compute_conditionals_drivers.R main: dim( stratified_resim_table ) = ", dim( stratified_resim_table ), "\n", sep = "\t" )
# readLines("stdin",n=1)

# pooled_sim_outfile = paste( pooled_sim_directory, "/", pooled_sim_file_name, sep = "" )
pooled_resim_outfile = paste( output_directory, "/", pooled_resim_file_name, sep = "" )
write.table( stratified_resim_table, file = pooled_resim_outfile , append = FALSE , quote = FALSE , sep = "\t" , row.names = FALSE , col.names = TRUE )

####################################################################################################
#
# Select summary statitics to be used in the Chi-squared calculation;
# Select observations from the posterior predictive distribution to be used in the Chi-squared calculation;
#

# cols_stats= c("mean_muts_sim", "n_singletons_1","clade_size_a_1","clade_size_b_1","clade_size_c_1","clade_size_d_1","clade_size_e_1","n_singletons_2","clade_size_a_2","clade_size_b_2","clade_size_c_2","clade_size_d_2","clade_size_e_2", "n_singletons_3", "clade_size_a_3","clade_size_b_3","clade_size_c_3","clade_size_d_3","clade_size_e_3","n_singletons_4", "clade_size_a_4","clade_size_b_4","clade_size_c_4","clade_size_d_4","clade_size_e_4", "ltt_1", "ltt_2", "ltt_3", "ltt_4", "coal_1", "coal_2", "coal_3")
stat_name_vect= c("n_singletons_1","clade_size_a_1","clade_size_b_1","clade_size_c_1","clade_size_d_1","clade_size_e_1","n_singletons_2","clade_size_a_2","clade_size_b_2","clade_size_c_2","clade_size_d_2","clade_size_e_2", "n_singletons_3", "clade_size_a_3","clade_size_b_3","clade_size_c_3","clade_size_d_3","clade_size_e_3","n_singletons_4", "clade_size_a_4","clade_size_b_4","clade_size_c_4","clade_size_d_4","clade_size_e_4", "ltt_1", "ltt_2", "ltt_3", "ltt_4", "coal_1", "coal_2", "coal_3")

# stats_included_col_names_vect = c(ltt_stats) # These are the summary stats used in the ABC computation;
stats_included_col_names_vect = stat_name_vect

stats_included_index_vect = which( cols_stats %in% stats_included_col_names_vect )
# stats_included_index_vect = 2:length( cols_stats ) # These are ALL the summary stats contained in "obs_stats_table" excluding column 1 ("mean_muts_data");
# stats_included_index_vect = 1:length( cols_stats )

sim_residual_included_col_names_vect = sim_residual_col_names_vect[ stats_included_index_vect ]
obs_residual_included_col_names_vect = obs_residual_col_names_vect[ stats_included_index_vect ]

residual_included_col_names_vect = c( sim_residual_included_col_names_vect, obs_residual_included_col_names_vect )

####################################################################################################
# 
# Create data frame "ppc_sample_table";
# 

ppc_sample_col_names_vect = c( "post_obs_index", "n_resims", "chisq_sim", "chisq_obs", "diff_chisq", residual_included_col_names_vect )
ppc_sample_table = as.data.frame( matrix( NA, nrow=nrow( stratified_resim_table ), ncol=length( ppc_sample_col_names_vect ) ) )
names( ppc_sample_table ) <- ppc_sample_col_names_vect

ppc_sample_table[ , c( "post_obs_index", "n_resims", residual_included_col_names_vect ) ] = stratified_resim_table[ , c( "post_obs_index", "n_resims", residual_included_col_names_vect ) ]

complete_rows_index_vect = complete.cases( ppc_sample_table[ , residual_included_col_names_vect ] )
ppc_sample_table = ppc_sample_table[ complete_rows_index_vect, ]

good_est_index_vect = which( ppc_sample_table[[ "n_resims" ]] >= n_resims_per_post_obs )
ppc_sample_table = ppc_sample_table[ good_est_index_vect, ]

# 
# Compute squares of standardised residuals;
#

# temp_table <- ppc_sample_table %>% mutate_at( residual_included_col_names_vect, function(x){ x^2 } )
temp_table <- ppc_sample_table[ , residual_included_col_names_vect ] %>% mutate_all( function(x){ x^2 } )

#
# Perform a Bayesian Chi-squared calculations;
#
ppc_sample_table[[ "chisq_sim" ]] = rowSums( temp_table[ , sim_residual_included_col_names_vect ] )
ppc_sample_table[[ "chisq_obs" ]]  = rowSums( temp_table[ , obs_residual_included_col_names_vect ] )
ppc_sample_table[[ "diff_chisq" ]] = ppc_sample_table[[ "chisq_sim" ]] - ppc_sample_table[[ "chisq_obs" ]]

####################################################################################################
#
# Count number of resims collected;
# 
# Write data outfile "resim_count_file.txt";
#

# n_resim_outfiles = length( resim_table_list )

n_resims_collected = nrow( stratified_resim_table )

n_complete_resims = length( which( complete.cases( stratified_resim_table[ , residual_included_col_names_vect ] ) ) )

n_post_obs_represented = length( unique( stratified_resim_table[[ "post_obs_index" ]] ) )

n_post_obs_good_est = length( unique( ppc_sample_table[[ "post_obs_index" ]] ) )

n_complete_resims_good_est = nrow( ppc_sample_table )

resim_count_outfile = paste( output_directory, "/", "resim_count_file", ".txt", sep = "" )
sink( file = resim_count_outfile )
# cat( "number of resim output files = ", length( resim_table_list ), "\n", sep = "\t" )
cat( "number of resim output files = ", n_resim_outfiles, "\n", sep = "\t" )
cat("\n")
cat( "number of resims collected = ", n_resims_collected, "\n", sep = "\t" )
cat("\n")
cat( "number of resims completed = ", n_complete_resims, "\n", sep = "\t" )
cat("\n")
cat( "number of posterior observations represented among the resims = ", n_post_obs_represented, "\n", sep = "\t" )
cat("\n")
cat( "minimum number of resims per posterior observations required for estimation = ", n_resims_per_post_obs, "\n", sep = "\t" )
cat("\n")
cat( "number of posterior observations which yield good estimates = ", n_post_obs_good_est, "\n", sep = "\t" )
cat("\n")
cat( "number of resims which contribute to good estimates = ", n_complete_resims_good_est, "\n", sep = "\t" )
sink()

####################################################################################################
# 
# Create data frame "stat_info_table";
# 

stat_info_col_names_vect = c( "stat_name", "n_sims_finite", "n_sims_NA" )
stat_info_table = as.data.frame( matrix( NA, nrow=length( stat_name_vect ), ncol=length( stat_info_col_names_vect) ) )
names( stat_info_table ) <- stat_info_col_names_vect

stat_info_table[[ "stat_name" ]] = stat_name_vect

n_sims_finite_vect = sapply( stat_name_vect, function(x){ length( which( is.finite( stratified_resim_table[[ x ]] ) ) ) } )

n_sims_NA_vect = sapply( stat_name_vect, function(x){ length( which( is.na( stratified_resim_table[[ x ]] ) ) ) } )

stat_info_table[[ "n_sims_finite" ]] = n_sims_finite_vect
stat_info_table[[ "n_sims_NA" ]] = n_sims_NA_vect

# 
# Write data frame "stat_info_table";
#

stat_info_outfile = paste( output_directory, "/", "stat_info_table", "_stat_set_", stat_set_ID, ".txt", sep = "" )
write.table( stat_info_table, file = stat_info_outfile , append = FALSE , quote = FALSE , sep = "\t" , row.names = FALSE , col.names = TRUE )

####################################################################################################
# 
# Create data frame "single_stat_tests_table";
# 

single_stat_tests_col_names_vect = c( "stat_name", "n_sims", "n_reject", "p_reject", "p_formatted" )
single_stat_tests_table = as.data.frame( matrix( NA, nrow=length( stat_name_vect ), ncol=length( single_stat_tests_col_names_vect) ) )
names( single_stat_tests_table ) <- single_stat_tests_col_names_vect

single_stat_tests_table[[ "stat_name" ]] = stat_name_vect

# 
# Compute squares of standardised residuals;
#

# temp_table <- ppc_sample_table %>% mutate_at( residual_included_col_names_vect, function(x){ x^2 } )
temp_table <- ppc_sample_table[ , residual_included_col_names_vect ] %>% mutate_all( function(x){ x^2 } )

# ppc_sample_table[[ "chisq_sim" ]] = rowSums( temp_table[ , sim_residual_included_col_names_vect ] )
# ppc_sample_table[[ "chisq_obs" ]]  = rowSums( temp_table[ , obs_residual_included_col_names_vect ] )
# ppc_sample_table[[ "diff_chisq" ]] = ppc_sample_table[[ "chisq_sim" ]] - ppc_sample_table[[ "chisq_obs" ]]

diff_table = as.data.frame( matrix( NA, nrow=nrow( ppc_sample_table ), ncol=length( stat_name_vect ) ) )
names( diff_table ) <- stat_name_vect

diff_table[ , stat_name_vect ] = temp_table[ , sim_residual_included_col_names_vect ] - temp_table[ , obs_residual_included_col_names_vect ]


n_sims_finite_vect = sapply( stat_name_vect, function(x){ length( which( is.finite( diff_table[[ x ]] ) ) ) } )

n_reject_vect = sapply( stat_name_vect, function(x){ length( which( diff_table[[ x ]][ is.finite( diff_table[[ x ]] ) ] > 0 ) ) } )

single_stat_tests_table[[ "n_sims" ]] = n_sims_finite_vect
single_stat_tests_table[[ "n_reject" ]] = n_reject_vect
single_stat_tests_table[[ "p_reject" ]] = single_stat_tests_table[[ "n_reject" ]] / single_stat_tests_table[[ "n_sims" ]]
single_stat_tests_table[[ "p_formatted" ]] = round( single_stat_tests_table[[ "p_reject" ]], digits = 4 )

# 
# Write data frame "single_stat_tests_table";
#

single_stat_tests_outfile = paste( output_directory, "/", "single_stat_tests_table", "_stat_set_", stat_set_ID, ".txt", sep = "" )
write.table( single_stat_tests_table, file = single_stat_tests_outfile , append = FALSE , quote = FALSE , sep = "\t" , row.names = FALSE , col.names = TRUE )

####################################################################################################
# 
# Create data frame "ppc_result_table";
# 

ppc_result_col_names_vect = c( "n_post_obs_represented", "min_resims_per_post_obs", "n_sims", "n_reject", "p_reject", "p_formatted", stats_included_col_names_vect )
ppc_result_table = as.data.frame( matrix( NA, nrow=1, ncol=length( ppc_result_col_names_vect) ) )
names( ppc_result_table ) <- ppc_result_col_names_vect

ppc_result_table[ , stats_included_col_names_vect ] = obs_stats_table[ , stats_included_col_names_vect ]

complete_rows_row_index_vect = which( is.finite( ppc_sample_table[[ "chisq_obs" ]] ) )
ppc_sample_table = ppc_sample_table[ complete_rows_index_vect, ]

n_post_obs_good_est = length( unique( ppc_sample_table[[ "post_obs_index" ]] ) )

#Estimate (Bayesian) p-value:
n_sims = nrow( ppc_sample_table )
n_reject = length( which( ppc_sample_table[[ "diff_chisq" ]] > 0 ) )
p_reject = n_reject / n_sims
p_formatted = round( p_reject, digits = 4 )

ppc_result_table[[ "n_post_obs_represented" ]][ 1 ] = n_post_obs_good_est
ppc_result_table[[ "min_resims_per_post_obs" ]][ 1 ] = n_resims_per_post_obs
ppc_result_table[[ "n_sims" ]][ 1 ] = n_sims
ppc_result_table[[ "n_reject" ]][ 1 ] = n_reject
ppc_result_table[[ "p_reject" ]][ 1 ] = p_reject
ppc_result_table[[ "p_formatted" ]][ 1 ] = p_formatted

# 
# Write data frame "ppc_result_table";
#

# pp_test_outfile = paste( output_directory, "/", "test_result_table", ".txt", sep = "" )
ppc_result_outfile = paste( output_directory, "/", "ppc_result_table", "_stat_set_", stat_set_ID, ".txt", sep = "" )
write.table( ppc_result_table, file = ppc_result_outfile , append = FALSE , quote = FALSE , sep = "\t" , row.names = FALSE , col.names = TRUE )

####################################################################################################
#
# Plot distributions;
#
setwd( output_directory )
system("mkdir pdfs")

#Plot posterior distribution of Chisq (= chisq_obs);
plot_title="Distribution of chisq_obs"
# pdf(paste0("pdfs/",ID, "_chisq_obs.pdf"))
pdf(paste0("pdfs/", "patient_", patient_ID, "_stat_set_", stat_set_ID, "_chisq_obs.pdf"))
hist( ppc_sample_table$chisq_obs, main = plot_title, xlab = "chisq_obs", breaks = 20)
dev.off()

#Plot posterior predictive distribution of Chisq (= chisq_sim);
plot_title="Distribution of chisq_sim"
# pdf(paste0("pdfs/",ID, "_chisq_sim.pdf"))
pdf(paste0("pdfs/", "patient_", patient_ID, "_stat_set_", stat_set_ID, "_chisq_sim.pdf"))
hist( ppc_sample_table$chisq_sim, main = plot_title, xlab = "chisq_sim", breaks = 20)
dev.off()

#Plot posterior distribution of diff_chisq (= chisq_sim - chisq_obs);
plot_title=paste0("Distribution of chisq_sim - chisq_obs (P value = ", p_formatted, ")")
# pdf(paste0("pdfs/",ID, "_diff_chisq.pdf"))
pdf(paste0("pdfs/", "patient_", patient_ID, "_stat_set_", stat_set_ID, "_diff_chisq.pdf"))
hist( ppc_sample_table$diff_chisq, main = plot_title, xlab = "chisq_sim - chisq_obs", breaks = 20)
abline(v = 0,col="red")
dev.off()

####################################################################################################

cat( "done!", "\n" )





